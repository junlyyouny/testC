# testC
> C语言练习片段汇总

### 线性表
1. [2-1.c](https://github.com/junlyyouny/testC/blob/master/2-1.c) 顺序表的创建、遍历、插入和删除
2. [2-2.c](https://github.com/junlyyouny/testC/blob/master/2-2.c) 已知顺序表的数据元素递增有序，在表中插入一个数据后仍保持顺序表有序
3. [2-3.c](https://github.com/junlyyouny/testC/blob/master/2-3.c) 单链表的创建（正生成）、遍历、插入（前插和后插）和删除
4. [2-4.c](https://github.com/junlyyouny/testC/blob/master/2-4.c) 创建一个“带头结点”的单链表，消除重复结点后将其反转（逆置）
5. [2-5.c](https://github.com/junlyyouny/testC/blob/master/2-5.c) 两个一元高次多项式相加
6. [Joseph.c](https://github.com/junlyyouny/testC/blob/master/Joseph.c) 约瑟夫问题-循环单链表
7. [linkList.c](https://github.com/junlyyouny/testC/blob/master/linkList.c) 单链表的创建和遍历

### 栈和队列
1. [3-1.c](https://github.com/junlyyouny/testC/blob/master/3-1.c) 将十进制数化成二进制数
2. [3-2.c](https://github.com/junlyyouny/testC/blob/master/3-2.c) 递归实现十翻二（内部使用栈）
3. [3-3.c](https://github.com/junlyyouny/testC/blob/master/3-3.c) 链队列的创建、遍历、入队和出队
4. [3-4.c](https://github.com/junlyyouny/testC/blob/master/3-4.c) 中缀表达式的求值

### 串
1. [4-1.c](https://github.com/junlyyouny/testC/blob/master/4-1.c) 串的长度和比较
2. [4-2.c](https://github.com/junlyyouny/testC/blob/master/4-2.c) 串的连接、子串和子串定位
3. [4-3.c](https://github.com/junlyyouny/testC/blob/master/4-3.c) 子串定位的简单模式匹配法

### 数组和广义表
1. [5-1.c](https://github.com/junlyyouny/testC/blob/master/5-1.c) 用三元组方法实现矩阵转置
2. [5-2.c](https://github.com/junlyyouny/testC/blob/master/5-2.c) 十字链表处理矩阵

### 树和二叉树
1. [6-1.c](https://github.com/junlyyouny/testC/blob/master/6-1.c) 二叉树的层次建立和遍历
2. [6-2.c](https://github.com/junlyyouny/testC/blob/master/6-2.c) 递归“先序”创建二叉树并用四种方法遍历（先序、中序、后序和按层次）
3. [6-3.c](https://github.com/junlyyouny/testC/blob/master/6-3.c) 家族树的建立和统计
4. [Huffman1.c](https://github.com/junlyyouny/testC/blob/master/Huffman1.c) 设有4个叶子结点A，B，C，D的权值分别是4，5，6，7，构建哈夫曼树
5. [Huffman2.c](https://github.com/junlyyouny/testC/blob/master/Huffman2.c) 设有8个叶子结点A，B，C，D，E，F，G，H的权值分别是5，29，7，8，14，23，3，11，构建哈夫曼树

### 图
1. [Depth1.c](https://github.com/junlyyouny/testC/blob/master/Depth1.c) 无向图根据其邻接矩阵进行深度优先遍历
2. [Depth2.c](https://github.com/junlyyouny/testC/blob/master/Depth2.c) 无向网根据其邻接矩阵进行深度优先遍历
3. [Depth3.c](https://github.com/junlyyouny/testC/blob/master/Depth3.c) 无向网根据其邻接表进行深度优先遍历
4. [Breadth1.c](https://github.com/junlyyouny/testC/blob/master/Breadth1.c) 有向图根据其邻接矩阵进行广度优先遍历
5. [Breadth2.c](https://github.com/junlyyouny/testC/blob/master/Breadth2.c) 无向网根据其邻接矩阵进行广度优先遍历
6. [Prim1.c](https://github.com/junlyyouny/testC/blob/master/Prim1.c) 用普里姆（Prim）算法画出无向网的最小生成树
7. [Prim2.c](https://github.com/junlyyouny/testC/blob/master/Prim2.c) 用普里姆（Prim）算法画出无向网的最小生成树
8. [Kruskal1.c](https://github.com/junlyyouny/testC/blob/master/Kruskal1.c) 用克鲁斯卡尔（Kruskal）算法画出无向网的最小生成树
9. [Kruskal2.c](https://github.com/junlyyouny/testC/blob/master/Kruskal2.c) 用克鲁斯卡尔（Kruskal）算法画出无向网的最小生成树
10. [Djstra1.c](https://github.com/junlyyouny/testC/blob/master/Djstra1.c) 用迪杰斯拉特拉(Dijkstra)算法求单源点A到各顶点的最短路径
11. [Djstra2.c](https://github.com/junlyyouny/testC/blob/master/Djstra2.c) 用迪杰斯拉特拉(Dijkstra)算法求单源顶点1到各顶点的最短路径
12. [Floyd.c](https://github.com/junlyyouny/testC/blob/master/Floyd.c) 用弗洛伊德(Floyd)算法求有向网的任意两顶点之间的最短距离

### 查找
1. [SeqBinSearch.c](https://github.com/junlyyouny/testC/blob/master/SeqBinSearch.c) 对顺序表的顺序查找和二分查找（折半查找）
2. [SortTree.c](https://github.com/junlyyouny/testC/blob/master/SortTree.c) 对二叉排序树的生成、遍历、查找和删除
3. [Hashlist.c](https://github.com/junlyyouny/testC/blob/master/Hashlist.c) 将十个关键字序列18，16，24，1，78，19，55，10，11，89，使用线性探查法，依次填入哈希表中
4. [Hashsqrt.c](https://github.com/junlyyouny/testC/blob/master/Hashsqrt.c) 将十个关键字序列12，13，25，23，38，34，6，84，91，92，设哈希表长度为m=14，哈希函数H(key)=key%11,使用平方探查法，依次填入哈希表中
5. [Hashdouble.c](https://github.com/junlyyouny/testC/blob/master/Hashdouble.c) 双散列函数探查法 h1(key)=key%11, h2(key)=key%9+1
6. [Link.c](https://github.com/junlyyouny/testC/blob/master/Link.c) 将关键字序列18，16，24，1，78，19，55，10，11，89，设哈希表长度为m=13，哈希函数H(key)=key%13,使用用链地址法存储并查找关键字

### 排序
1. [Student.c](https://github.com/junlyyouny/testC/blob/master/Student.c) 学生登记表
2. [Bubble1.c](https://github.com/junlyyouny/testC/blob/master/Bubble1.c) 冒泡排序
3. [Bubble2.c](https://github.com/junlyyouny/testC/blob/master/Bubble2.c) 向前冒泡
4. [Select.c](https://github.com/junlyyouny/testC/blob/master/Select.c) 选择排序
5. [Direct.c](https://github.com/junlyyouny/testC/blob/master/Direct.c) 直接选择排序
6. [Insert.c](https://github.com/junlyyouny/testC/blob/master/Insert.c) 直接插入排序
7. [Quick.c](https://github.com/junlyyouny/testC/blob/master/Quick.c) 快速排序
8. [Heap.c](https://github.com/junlyyouny/testC/blob/master/Heap.c) 堆排序
9. [Merge.c](https://github.com/junlyyouny/testC/blob/master/Merge.c) 归并排序
10. [Shell.c](https://github.com/junlyyouny/testC/blob/master/Shell.c) 谢尔排序
11. [Radix.c](https://github.com/junlyyouny/testC/blob/master/Radix.c) 基数排序